"""Resolves name and connects socket with IPv4/IPv6 portability"""


import logging
import socket



g_log = logging.getLogger(__name__)



def connect_tcp(host, port):
  """Establish a TCP/IP connection

  :returns: A successfully-connected socket
  :rtype: socket.socket

  :raises socket.gaierror: address resolution error
  :raises socket.error: socket connection error
  """
  return connect(host,
                 port,
                 family=0,
                 socktype=0,
                 proto=socket.IPPROTO_TCP,
                 flags=0)



def connect(host, port, family=0, socktype=0, proto=0, flags=0):
  """ Perform address resolution via `socket.getaddrinfo` and return socket
  from the first successful conneciton attempt.

  The arguments are passed to socket.getaddrinfo to refine address resolution.
  See `socket.getaddrinfo` for details.

  :param str host: domain name, a string representation of an IPv4/v6 address
  :param port: port is a string service name such as 'http', a numeric port
    number or 0.
  :type port: str, int
  :param int family: one of socket.AF_*; 0 (AF_UNSPEC) means the full range of
    results is selected.
  :param int socktype: typically sock.SOCK_STREAM or sock.DGRAM
  :param int proto: socket.IPPROTO_*; e.g., socket.IPPROTO_TCP; defaults to 0,
    which indicates that socket addresses with any protocol can be returned
  :param int flags: one or serveral of the socket.AI_* constants; influences how
    results are computed and returned

  :raises socket.gaierror: address resolution error
  :raises socket.error: socket connection error
  """
  infos = socket.getaddrinfo(host, port, family, socktype, proto, flags)
  return connect_from_addr_infos(infos)



def connect_from_addr_infos(infos):
  """Given a sequence of elements generated by `socket.getaddrinfo`, attempt
  connection to each one of them in the given order.

  :param infos: sequence of tuples that are compatible with the results returned
    by `socket.getaddrinfo`

  :returns: A successfully-connected socket; None if given an empty sequence
  :rtype: socket.socket or None

  :socket.error:
  """
  if not infos:
    return None

  for count, res in enumerate(infos, 1):
    family, socktype, proto, _canonname, address = res

    # Attempt to create a socket
    try:
      sock = socket.socket(family, socktype, proto)
    except socket.error:
      if count < len(infos):
        g_log.debug("socket.socket(%r, %r, %r) failed", family, socktype, proto,
                    exc_info=True)
        continue
      else:
        raise

    # Attempt to connect
    try:
      sock.connect(address)
    except socket.error as msg:
      sock.close()
      sock = None

      if count < len(infos):
        g_log.debug("sock.connect(%r) failed", address, exc_info=True)
        continue
      else:
        raise
    else:
      return sock


  # Should never get here!
  raise RuntimeError("Failed to connect, but didn't raise; infos: %r"
                     % (infos,))
